<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Virtual Scratch Ticket</title>

  <!-- Social Preview (STATIC snapshot for platforms) -->
  <meta property="og:title" content="Virtual Scratch Ticket" id="ogTitle" />
  <meta property="og:description" content="Scratch to reveal your surprise!" id="ogDesc" />
  <meta property="og:image" content="https://i.imgur.com/GjmafAj.png" id="ogImage" />
  <meta property="og:type" content="website" id="ogType" />

  <meta name="twitter:card" content="summary_large_image" id="twCard" />
  <meta name="twitter:title" content="Virtual Scratch Ticket" id="twTitle" />
  <meta name="twitter:description" content="Scratch to reveal your surprise!" id="twDesc" />
  <meta name="twitter:image" content="https://i.imgur.com/GjmafAj.png" id="twImage" />

  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8E%9F%EF%B8%8F%3C/text%3E%3C/svg%3E">

  <!-- Fonts: UI + ticket text -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link id="googleFontsLink" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Ropa+Sans:wght@400&family=Inter:wght@400;500;600&display=swap">

  <!-- ================= CONFIG (edit here) ================= -->
  <script>
    const CONFIG = {
      debug: false,
      canvas: { width: 1080, height: 1920 },

      images: {
        backgroundVideo: './background.mp4',
        poster: 'https://i.imgur.com/GjmafAj.png',
        backgroundFallback: 'https://i.imgur.com/8GqRmQz.gif',
        scratchOverlay: 'https://i.imgur.com/MKi32hJ.png'
      },

      social: {
        title: 'Virtual Scratch Ticket',
        description: 'Scratch to reveal your surprise!',
        image: 'https://i.imgur.com/GjmafAj.png',
        ogType: 'website',
        twitterCard: 'summary_large_image'
      },

      googleFontsHref: 'https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Ropa+Sans:wght@400&family=Inter:wght@400;500;600&display=swap',

      fonts: {
        slab: "'Alfa Slab One', 'Georgia', serif",
        sans: "'Ropa Sans', 'Arial', sans-serif"
      },
      defaultFontKey: 'slab',

      // Per-field text transform
      textTransform: {
        default: 'uppercase', // uppercase | none | capitalize | lowercase
        fields: {
          message: 'uppercase',
          name: 'uppercase',
          artist: 'uppercase',
          venue: 'uppercase',
          date: 'uppercase'
        }
      },

      ui: {
        messageMaxChars: 140,
        messageMaxLines: 2,
        messageLineHeight: 1.15
      },

      fields: {
        message: { x: 540, y: 630,  boxWidth: 901.7109, boxHeight: 145.7813, fontSize: 48, fontWeight: 400, align: 'center', fontKey: 'sans' },
        name:    { x: 540, y: 487,  boxWidth: 901.7109, boxHeight: 137.7813, fontSize: 80, fontWeight: 400, align: 'center', fontKey: 'slab' },
        artist:  { x: 540, y: 1052, boxWidth: 901.7109, boxHeight: 269.7813, fontSize: 1000, fontWeight: 400, align: 'center', fontKey: 'slab' },
        venue:   { x: 306, y: 1523, boxWidth: 432.293,  boxHeight: 101.7871, fontSize: 30, fontWeight: 400, align: 'center', fontKey: 'slab' },
        date:    { x: 780, y: 1523, boxWidth: 432.293,  boxHeight: 101.7871, fontSize: 30, fontWeight: 400, align: 'center', fontKey: 'slab' }
      },

      minFontSize: { message: 14, name: 14, artist: 14, venue: 14, date: 14 },

      scratch: {
        brushSize: 120,
        brushMode: 'stroke' // stroke | circle
      },

      reveal: {
        textDelayMs: 150
      },

      // Font loading: if fonts are slow on mobile, we don't want to hide text for long.
      // After this timeout, the ticket will render with whatever fonts are available.
      fontsWaitMs: 600
      },

      share: {
        baseUrl: ''
      },

      assetsVersion: 'v1'
    };
  </script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', Arial, sans-serif;
      background: #fff;
      height: 100dvh;
      min-height: 100dvh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
      overflow: hidden;
    }

    .container {
      width: 100%;
      max-width: 600px;
      height: 100dvh;
      max-height: 100dvh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 10px;
      min-height: 0;
    }

    #fatalError {
      display: none;
      padding: 12px;
      border-radius: 12px;
      background: #fff0f0;
      border: 1px solid rgba(176,0,32,0.25);
      color: #7a1d2a;
      font-family: 'Inter', Arial, sans-serif;
    }

    /* Ticket loading shimmer */
    .loading-wrap {
      display: none;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
    }
    .loading-wrap.active { display: block; }

    .loading-card {
      width: 100%;
      aspect-ratio: 9 / 16;
      border-radius: 16px;
      background: #f6f0e8;
      overflow: hidden;
      position: relative;
      box-shadow: 0 6px 16px rgba(0,0,0,0.08);
    }

    .shimmer {
      position: absolute;
      inset: 0;
      transform: translateX(-100%);
      background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,0.6), rgba(255,255,255,0));
      animation: shimmer 1.1s infinite;
    }

    .loading-text {
      margin-top: 10px;
      text-align: center;
      font-size: 14px;
      color: #6b5a46;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* ---------- EDITOR ---------- */
    .editor {
      display: none;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .editor.active { display: block; }

    .editor h2 {
      text-align: center;
      margin-top: 20px;
      margin-bottom: 10px;
      font-weight: 600;
      color: #333;
    }

    .editor p {
      font-size: 14px;
      text-align: center;
      margin-bottom: 12px;
      color: #666;
      line-height: 1.4;
    }

    .field-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: #5a4a3a;
      margin: 10px 2px 6px;
    }

    .editor input {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid #ddd;
    }

    .editor input:focus {
      outline: none;
      border-color: #e8c9a8;
      box-shadow: 0 0 0 3px rgba(232,201,168,0.25);
    }

    .editor button {
      width: 100%;
      padding: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #f3d6b6, #f0caa0);
      color: #4a3b2a;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      margin-bottom: 10px;
    }

    #messageCounter {
      font-size: 12px;
      color: #777;
      margin: -4px 0 10px;
      text-align: right;
    }

    /* ---------- VIEW ---------- */
    .view {
      display: none;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      flex-direction: column;
      gap: 10px;
    }
    .view.active { display: flex; }

    .card-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 9 / 16;
      overflow: hidden;
      background: #fff;
      flex: 1 1 auto;
      min-height: 0;
    }

    .bg-media {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      z-index: 0;
    }

    .text-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      opacity: 1;
      transition: opacity 120ms ease;
    }

    /* Prevent visible font/size "jump" while fonts load */
    .rendering .text-layer { opacity: 0; }

    .text {
      position: absolute;
      color: #111;
      overflow: hidden;
      text-shadow: none;
      word-wrap: break-word;
    }

    body.debug .text { outline: 1px dashed rgba(255,0,0,0.8); background: rgba(255,0,0,0.08); }

    canvas {
      position: absolute;
      z-index: 2;
      touch-action: none;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      flex-shrink: 0;
    }

    .actions button {
      width: 100%;
      padding: 12px;
      font-size: 15px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.10);
      background: #fff;
      cursor: pointer;
    }

    .actions button.primary {
      background: linear-gradient(135deg, #f3d6b6, #f0caa0);
      border: none;
      color: #4a3b2a;
      font-weight: 600;
    }

    .link-status {
      width: 100%;
      font-size: 13px;
      color: #6b5a46;
      text-align: center;
      display: none;
    }

    .instructions {
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: #6b5a46;
      line-height: 1.4;
      flex-shrink: 0;
    }

    @media (max-width: 480px) {
      body { padding: 8px; }
      .container { gap: 8px; }
      .instructions { font-size: 13px; }
      .actions button { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="fatalError"><strong>Oops — something didn’t load correctly.</strong><br>Please refresh. If it keeps happening, open the console and copy the first red error line.</div>

    <div class="editor" id="editor">
      <h2>Customize Your Ticket</h2>
      <p>Fill in the details below. You’ll preview your ticket before generating a shareable link.</p>

      <label class="field-label" for="nameInput">Recipient Name</label>
      <input id="nameInput" placeholder="Type here…" maxlength="40" />

      <label class="field-label" for="messageInput">Message</label>
      <input id="messageInput" placeholder="Type your custom message here…" />
      <div id="messageCounter">0/140</div>

      <label class="field-label" for="artistInput">Artist</label>
      <input id="artistInput" placeholder="Type here…" maxlength="40" />

      <label class="field-label" for="venueInput">Venue</label>
      <input id="venueInput" placeholder="Type here…" maxlength="50" />

      <label class="field-label" for="dateInput">Date</label>
      <input id="dateInput" placeholder="Type here…" maxlength="30" />

      <button id="previewBtn" type="button">Preview Ticket</button>
    </div>

    <div class="loading-wrap" id="loadingWrap">
      <div class="loading-card">
        <div class="shimmer"></div>
      </div>
      <div class="loading-text" id="loadingText">Loading your ticket…</div>
      <div class="loading-text" style="font-size:12px; opacity:0.85;">(This usually takes less than a second)</div>
    </div>

    <div class="view" id="view">
      <div class="card-wrapper" id="card">
        <video id="bgVideo" class="bg-media" autoplay loop muted playsinline preload="metadata"></video>
        <img id="bgImg" class="bg-media" alt="Scratch ticket" />

        <div class="text-layer">
          <div class="text" id="tName"></div>
          <div class="text" id="tEvent"></div>
          <div class="text" id="tArtist"></div>
          <div class="text" id="tVenue"></div>
          <div class="text" id="tDate"></div>
        </div>

        <canvas id="scratchCanvas" style="display:none;"></canvas>
      </div>

      <div class="actions" id="actions">
        <button id="backBtn" type="button">← Back to Edit</button>
        <button id="generateBtn" type="button">Generate Shareable Link</button>
        <button id="copyBtn" type="button" class="primary" style="display:none;">Copy Link</button>
        <div class="link-status" id="linkStatus">Link ready — tap <b>Copy Link</b> to share.</div>
      </div>

      <div class="instructions" id="instructions"></div>
    </div>
  </div>

  <script>
    const fatalError = document.getElementById('fatalError');
    window.addEventListener('error', (e) => {
      console.error(e.error || e.message);
      if (fatalError) fatalError.style.display = 'block';
    });

    function setMeta(id, value) {
      const el = document.getElementById(id);
      if (el && value) el.setAttribute('content', value);
    }

    function applySocialMetaFromConfig() {
      if (CONFIG.social?.title) document.title = CONFIG.social.title;
      setMeta('ogTitle', CONFIG.social?.title);
      setMeta('ogDesc', CONFIG.social?.description);
      setMeta('ogImage', CONFIG.social?.image);
      setMeta('ogType', CONFIG.social?.ogType);
      setMeta('twCard', CONFIG.social?.twitterCard);
      setMeta('twTitle', CONFIG.social?.title);
      setMeta('twDesc', CONFIG.social?.description);
      setMeta('twImage', CONFIG.social?.image);
    }

    function ensureGoogleFontsLink() {
      const link = document.getElementById('googleFontsLink');
      if (link && CONFIG.googleFontsHref) link.setAttribute('href', CONFIG.googleFontsHref);
    }

    function withCacheBust(url) {
      if (!url) return url;
      const v = String(CONFIG.assetsVersion || '').trim();
      if (!v) return url;
      return url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(v);
    }

    function encodeState(obj) {
      try {
        const compact = { n: obj.name || '', m: obj.message || '', a: obj.artist || '', v: obj.venue || '', d: obj.date || '' };
        Object.keys(compact).forEach(k => { if (!compact[k]) delete compact[k]; });
        const json = JSON.stringify(compact);
        const b64 = btoa(unescape(encodeURIComponent(json)));
        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      } catch { return ''; }
    }

    function decodeState(str) {
      try {
        let b64 = (str || '').replace(/-/g, '+').replace(/_/g, '/');
        while (b64.length % 4) b64 += '=';
        const json = decodeURIComponent(escape(atob(b64)));
        const compact = JSON.parse(json);
        if (!compact || typeof compact !== 'object') return null;
        return { name: compact.n || '', message: compact.m || '', artist: compact.a || '', venue: compact.v || '', date: compact.d || '' };
      } catch { return null; }
    }

    const params = new URLSearchParams(window.location.search);
    const isReveal = params.get('mode') === 'reveal';

    const editor = document.getElementById('editor');
    const loadingWrap = document.getElementById('loadingWrap');
    const loadingText = document.getElementById('loadingText');
    const view = document.getElementById('view');
    const card = document.getElementById('card');
    const actions = document.getElementById('actions');
    const instructions = document.getElementById('instructions');

    const bgVideo = document.getElementById('bgVideo');
    const bgImg = document.getElementById('bgImg');
    const scratchCanvas = document.getElementById('scratchCanvas');

    const inputs = {
      name: document.getElementById('nameInput'),
      message: document.getElementById('messageInput'),
      artist: document.getElementById('artistInput'),
      venue: document.getElementById('venueInput'),
      date: document.getElementById('dateInput')
    };

    const fields = {
      name: document.getElementById('tName'),
      message: document.getElementById('tEvent'),
      artist: document.getElementById('tArtist'),
      venue: document.getElementById('tVenue'),
      date: document.getElementById('tDate')
    };

    const state = { name: '', message: '', artist: '', venue: '', date: '' };
    let lastScale = 1;

    async function waitForFonts() {
      // Wait for ONLY the ticket fonts, but never block for too long.
      const timeoutMs = Number(CONFIG.fontsWaitMs ?? 600);

      try {
        if (!document.fonts || !document.fonts.load) return;

        const ticketLoads = Promise.allSettled([
          document.fonts.load('16px "Alfa Slab One"'),
          document.fonts.load('16px "Ropa Sans"')
        ]);

        const timeout = new Promise((resolve) => setTimeout(resolve, timeoutMs));

        // Race: either fonts load, or we time out.
        await Promise.race([ticketLoads, timeout]);
      } catch (e) {
        // non-fatal
      }
    }

    async function renderTicket() {
      // One place to do: wait for fonts -> layout -> text -> auto-shrink
      await waitForFonts();
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      applyFieldLayout();
      applyStateToFields();
    }

    function setDebugMode(on) { document.body.classList.toggle('debug', !!on); }

    function updateMessageCounter() {
      const counter = document.getElementById('messageCounter');
      const max = Number(inputs.message?.maxLength || CONFIG.ui.messageMaxChars || 140);
      const len = (inputs.message?.value || '').length;
      if (counter) counter.textContent = `${len}/${max}`;
    }

    function pullInputsToState() {
      for (const key in inputs) state[key] = (inputs[key].value || '').trim();
    }

    function pushStateToInputs() {
      for (const key in inputs) inputs[key].value = state[key] || '';
      updateMessageCounter();
    }

    function loadStateFromParams() {
      const packed = params.get('d');
      if (packed) {
        const decoded = decodeState(packed);
        if (decoded) { Object.assign(state, decoded); return; }
      }
      for (const key in state) state[key] = (params.get(key) || '').trim();
    }

    function applyFieldLayout() {
      const wrapRect = card.getBoundingClientRect();
      const wrapW = wrapRect.width;
      const wrapH = wrapRect.height;

      const natW = (bgVideo && bgVideo.videoWidth) || (bgImg && bgImg.naturalWidth) || CONFIG.canvas.width;
      const natH = (bgVideo && bgVideo.videoHeight) || (bgImg && bgImg.naturalHeight) || CONFIG.canvas.height;

      const scale = Math.min(wrapW / natW, wrapH / natH);
      lastScale = scale;

      const contentW = natW * scale;
      const contentH = natH * scale;
      const offsetX = (wrapW - contentW) / 2;
      const offsetY = (wrapH - contentH) / 2;

      scratchCanvas.style.left = offsetX + 'px';
      scratchCanvas.style.top = offsetY + 'px';
      scratchCanvas.style.width = contentW + 'px';
      scratchCanvas.style.height = contentH + 'px';

      for (const key in CONFIG.fields) {
        const cfg = CONFIG.fields[key];
        const el = fields[key];
        if (!el) continue;

        el.style.left = (offsetX + cfg.x * scale) + 'px';
        el.style.top  = (offsetY + cfg.y * scale) + 'px';
        el.style.transform = 'translate(-50%, -50%)';
        el.style.width = (cfg.boxWidth * scale) + 'px';
        el.style.height = (cfg.boxHeight * scale) + 'px';

        const fontKey = cfg.fontKey || CONFIG.defaultFontKey;
        el.style.fontFamily = CONFIG.fonts[fontKey] || 'Arial, sans-serif';
        el.style.fontSize = (cfg.fontSize * scale) + 'px';
        el.style.fontWeight = String(cfg.fontWeight ?? 400);
        el.style.textAlign = cfg.align || 'center';

        const tf = (CONFIG.textTransform?.fields && CONFIG.textTransform.fields[key])
          ? CONFIG.textTransform.fields[key]
          : (CONFIG.textTransform?.default || 'uppercase');
        el.style.textTransform = tf;

        // Align text in the box
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = (el.style.textAlign === 'left') ? 'flex-start' : (el.style.textAlign === 'right') ? 'flex-end' : 'center';

        if (key === 'message') {
          el.style.lineHeight = String(CONFIG.ui.messageLineHeight || 1.15);
          el.style.display = '-webkit-box';
          el.style.webkitBoxOrient = 'vertical';
          el.style.webkitLineClamp = String(CONFIG.ui.messageMaxLines || 2);
          el.style.overflow = 'hidden';
        } else {
          el.style.lineHeight = 'normal';
          el.style.webkitLineClamp = '';
          el.style.webkitBoxOrient = '';
          el.style.overflow = 'hidden';
        }
      }
    }

    function resetTextStyles() {
      for (const key in CONFIG.fields) {
        const el = fields[key];
        const cfg = CONFIG.fields[key];
        if (!el) continue;
        el.style.fontSize = (cfg.fontSize * lastScale) + 'px';
      }
    }

    function autoShrink(el, minAe) {
      const maxHeight = el.offsetHeight;
      let size = parseFloat(getComputedStyle(el).fontSize);
      const min = Math.max(8, Number(minAe || 10) * lastScale);
      let guard = 250;
      while ((el.scrollHeight > maxHeight || el.scrollWidth > el.offsetWidth) && size > min && guard-- > 0) {
        size -= 1;
        el.style.fontSize = size + 'px';
      }
    }

    function applyStateToFields() {
      resetTextStyles();
      for (const key in fields) fields[key].textContent = state[key] || '';
      for (const key in fields) autoShrink(fields[key], CONFIG.minFontSize[key]);
    }

    function showEditor() {
      editor.classList.add('active');
      view.classList.remove('active');
      loadingWrap.classList.remove('active');
      scratchCanvas.style.display = 'none';
    }

    function showPreview() {
      editor.classList.remove('active');
      view.classList.remove('active');
      loadingWrap.classList.add('active');
      if (loadingText) loadingText.textContent = 'Loading your ticket…';

      scratchCanvas.style.display = 'none';
      actions.style.display = 'flex';
      instructions.textContent = 'Preview your ticket ✨ If anything looks off, tap Back to Edit to fix it.';

      // Hide ticket text until fonts/layout are ready
      card.classList.add('rendering');

      renderTicket()
        .then(() => {
          loadingWrap.classList.remove('active');
          view.classList.add('active');
        })
        .finally(() => {
          card.classList.remove('rendering');
        });
    }

    function showReveal() {
      editor.classList.remove('active');
      view.classList.remove('active');
      loadingWrap.classList.add('active');
      if (loadingText) loadingText.textContent = 'Loading your ticket…';

      actions.style.display = 'none';
      instructions.textContent = '✨ Scratch to reveal your surprise! ✨';
      for (const key in fields) fields[key].style.visibility = 'hidden';
      scratchCanvas.style.display = 'block';

      card.classList.add('rendering');

      renderTicket()
        .then(() => {
          loadingWrap.classList.remove('active');
          view.classList.add('active');
        })
        .finally(() => {
          card.classList.remove('rendering');
        });
    }

    function initScratch() {
      const canvas = scratchCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const overlay = new Image();
      overlay.crossOrigin = 'anonymous';
      overlay.src = withCacheBust(CONFIG.images.scratchOverlay);

      overlay.onload = () => {
        canvas.width = overlay.width;
        canvas.height = overlay.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(overlay, 0, 0);

        setTimeout(() => {
          for (const key in fields) fields[key].style.visibility = 'visible';
        }, Number(CONFIG.reveal?.textDelayMs || 150));
      };

      let scratching = false;
      let last = null;

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function eraseStroke(pos) {
        const size = Number(CONFIG.scratch?.brushSize || 120);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (!last) {
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y);
          ctx.lineTo(pos.x + 0.01, pos.y + 0.01);
          ctx.stroke();
          last = pos;
          return;
        }
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        last = pos;
      }

      function eraseCircle(pos) {
        const radius = Number(CONFIG.scratch?.brushSize || 120) / 2;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      function eraseAt(e) {
        const pos = getPos(e);
        const mode = String(CONFIG.scratch?.brushMode || 'stroke').toLowerCase();
        if (mode === 'circle') eraseCircle(pos);
        else eraseStroke(pos);
      }

      canvas.onpointerdown = (e) => { scratching = true; last = null; eraseAt(e); };
      canvas.onpointerup = () => { scratching = false; last = null; };
      canvas.onpointerleave = () => { scratching = false; last = null; };
      canvas.onpointermove = (e) => { if (!scratching) return; eraseAt(e); };
    }

    (function boot() {
      try {
        applySocialMetaFromConfig();
        ensureGoogleFontsLink();
        setDebugMode(!isReveal && CONFIG.debug);

        if (inputs.message) {
          inputs.message.maxLength = Number(CONFIG.ui.messageMaxChars || 140);
          inputs.message.addEventListener('input', updateMessageCounter);
          updateMessageCounter();
        }

        // Load background media
        if (CONFIG.images.poster) bgVideo.setAttribute('poster', withCacheBust(CONFIG.images.poster));
        bgVideo.src = withCacheBust(CONFIG.images.backgroundVideo);
        bgVideo.addEventListener('error', () => {
          bgVideo.style.display = 'none';
          bgImg.style.display = 'block';
        });
        bgVideo.addEventListener('loadedmetadata', () => {
          applyFieldLayout();
          if (view.classList.contains('active')) renderTicket();
        });

        bgImg.src = withCacheBust(CONFIG.images.backgroundFallback);
        bgImg.style.display = 'none';
        bgImg.addEventListener('load', () => {
          applyFieldLayout();
          if (view.classList.contains('active')) renderTicket();
        });

        window.addEventListener('resize', () => {
          applyFieldLayout();
          if (view.classList.contains('active')) renderTicket();
        });

        if (isReveal) {
          loadStateFromParams();
          showReveal();
          applyStateToFields();
          initScratch();
        } else {
          showEditor();
        }

        document.getElementById('previewBtn')?.addEventListener('click', () => {
          pullInputsToState();
          showPreview();
        });

        document.getElementById('backBtn')?.addEventListener('click', () => {
          pushStateToInputs();
          showEditor();
        });

        const generateBtn = document.getElementById('generateBtn');
        const copyBtn = document.getElementById('copyBtn');
        const linkStatus = document.getElementById('linkStatus');
        let lastGeneratedLink = '';

        generateBtn?.addEventListener('click', () => {
          const base = (CONFIG.share && typeof CONFIG.share.baseUrl === 'string' && CONFIG.share.baseUrl.trim())
            ? CONFIG.share.baseUrl.trim()
            : window.location.href;

          const url = new URL(base);
          url.searchParams.set('mode', 'reveal');
          const packed = encodeState(state);
          if (packed) url.searchParams.set('d', packed);
          lastGeneratedLink = url.toString();

          if (linkStatus) linkStatus.style.display = 'block';
          if (copyBtn) copyBtn.style.display = 'block';

          requestAnimationFrame(() => { applyFieldLayout(); applyStateToFields(); });
        });

        copyBtn?.addEventListener('click', async () => {
          if (!lastGeneratedLink) return;
          const setCopied = () => {
            copyBtn.textContent = 'Copied! ✓';
            setTimeout(() => { copyBtn.textContent = 'Copy Link'; }, 1500);
          };

          try {
            if (navigator.clipboard?.writeText) {
              await navigator.clipboard.writeText(lastGeneratedLink);
              setCopied();
              return;
            }
          } catch (e) { /* fall back */ }

          const temp = document.createElement('textarea');
          temp.value = lastGeneratedLink;
          temp.setAttribute('readonly', '');
          temp.style.position = 'fixed';
          temp.style.left = '-9999px';
          document.body.appendChild(temp);
          temp.select();
          try { document.execCommand('copy'); } catch (e) {}
          document.body.removeChild(temp);
          setCopied();
        });
      } catch (e) {
        console.error(e);
        if (fatalError) fatalError.style.display = 'block';
      }
    })();
  </script>
</body>
</html>
