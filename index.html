<!DOCTYPE html>
<!--
  =============================================================
  Virtual Concert Scratch-Off Ticket (One-link, passive)
  =============================================================
  Edit only in CONFIG for new designs.
  - Background: MP4 on GitHub Pages recommended
  - Scratch overlay: PNG
  - Reveal links: spoiler-safe + shorter (?mode=reveal&d=...)
  - Copy Link button: hides raw URL
  =============================================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Virtual Scratch Ticket</title>

  <!-- Social Preview (STATIC snapshot for platforms) -->
  <meta property="og:title" content="Virtual Scratch Ticket" id="ogTitle" />
  <meta property="og:description" content="Scratch to reveal your surprise!" id="ogDesc" />
  <meta property="og:image" content="https://i.imgur.com/GjmafAj.png" id="ogImage" />
  <meta property="og:type" content="website" id="ogType" />

  <meta name="twitter:card" content="summary_large_image" id="twCard" />
  <meta name="twitter:title" content="Virtual Scratch Ticket" id="twTitle" />
  <meta name="twitter:description" content="Scratch to reveal your surprise!" id="twDesc" />
  <meta name="twitter:image" content="https://i.imgur.com/GjmafAj.png" id="twImage" />

  <!-- Tiny favicon to avoid 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8E%9F%EF%B8%8F%3C/text%3E%3C/svg%3E">

  <!-- Fonts: UI + ticket text -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link id="googleFontsLink" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Ropa+Sans:wght@400&family=Inter:wght@400;500;600&display=swap">

  <!-- ================= CONFIG (edit here) ================= -->
  <script>
    const CONFIG = {
      debug: false,

      canvas: { width: 1080, height: 1920 },

      images: {
        // Put background.mp4 in the same repo folder as index.html
        backgroundVideo: './background.mp4',
        // Optional fallback if video fails
        backgroundFallback: 'https://i.imgur.com/8GqRmQz.gif',
        scratchOverlay: 'https://i.imgur.com/MKi32hJ.png'
      },

      social: {
        title: 'Virtual Scratch Ticket',
        description: 'Scratch to reveal your surprise!',
        image: 'https://i.imgur.com/GjmafAj.png',
        ogType: 'website',
        twitterCard: 'summary_large_image'
      },

      googleFontsHref: 'https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Ropa+Sans:wght@400&family=Inter:wght@400;500;600&display=swap',

      fonts: {
        slab: "'Alfa Slab One', 'Georgia', serif",
        sans: "'Ropa Sans', 'Arial', sans-serif"
      },
      defaultFontKey: 'slab',

      ui: {
        messageMaxChars: 140,
        messageMaxLines: 2,
        messageLineHeight: 1.15
      },

      fields: {
        message: { x: 540, y: 630,  boxWidth: 901.7109, boxHeight: 145.7813, fontSize: 48, fontWeight: 400, align: 'center', fontKey: 'sans' },
        name:    { x: 540, y: 487,  boxWidth: 901.7109, boxHeight: 137.7813, fontSize: 80, fontWeight: 400, align: 'center', fontKey: 'slab' },
        artist:  { x: 540, y: 1052, boxWidth: 901.7109, boxHeight: 269.7813, fontSize: 80, fontWeight: 400, align: 'center', fontKey: 'slab' },
        venue:   { x: 306, y: 1523, boxWidth: 432.293,  boxHeight: 101.7871, fontSize: 30, fontWeight: 400, align: 'center', fontKey: 'slab' },
        date:    { x: 780, y: 1523, boxWidth: 432.293,  boxHeight: 101.7871, fontSize: 30, fontWeight: 400, align: 'center', fontKey: 'slab' }
      },

      minFontSize: { message: 14, name: 14, artist: 14, venue: 14, date: 14 },

      scratch: {
        brushSize: 120,
        brushMode: 'stroke'
      },

      reveal: {
        textDelayMs: 150
      },

      share: {
        // Set after your page is live, e.g.
        // baseUrl: 'https://sidehustlenalette-svg.github.io/customconcertscratchoff/'
        baseUrl: ''
      },

      assetsVersion: 'v1'
    };
  </script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', Arial, sans-serif;
      background: #fff;
      height: 100dvh;           /* mobile-safe viewport height */
      min-height: 100dvh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
      overflow: hidden;         /* keep everything on one screen */
    }

    .container {
      width: 100%;
      max-width: 600px;
      height: 100dvh;           /* allow internal flex to size without page scroll */
      max-height: 100dvh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 10px;
      min-height: 0;            /* IMPORTANT for flex children to shrink */
    }

    /* Error banner */
    #fatalError {
      display: none;
      padding: 12px;
      border-radius: 12px;
      background: #fff0f0;
      border: 1px solid rgba(176,0,32,0.25);
      color: #7a1d2a;
      font-family: 'Inter', Arial, sans-serif;
    }

    /* ---------- EDITOR ---------- */
    .editor {
      display: none;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;           /* if keyboard makes it tight, allow internal scroll only */
      -webkit-overflow-scrolling: touch;
    }
    .editor.active { display: block; }

    .editor h2 {
      text-align: center;
      margin-bottom: 10px;
      font-weight: 600;
      color: #333;
    }

    .editor p {
      font-size: 14px;
      text-align: center;
      margin-bottom: 12px;
      color: #666;
      line-height: 1.4;
    }

    .field-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: #5a4a3a;
      margin: 10px 2px 6px;
    }

    .editor input {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      font-size: 16px; /* prevents mobile auto-zoom */
      border-radius: 10px;
      border: 1px solid #ddd;
    }

    .editor input:focus {
      outline: none;
      border-color: #e8c9a8;
      box-shadow: 0 0 0 3px rgba(232,201,168,0.25);
    }

    .editor button {
      width: 100%;
      padding: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #f3d6b6, #f0caa0);
      color: #4a3b2a;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    }

    #messageCounter {
      font-size: 12px;
      color: #777;
      margin: -4px 0 10px;
      text-align: right;
    }

    /* ---------- VIEW (ticket + footer) ---------- */
    .view {
      display: none;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      flex-direction: column;
      gap: 10px;
    }
    .view.active { display: flex; }
    .view.active { display: flex; }

    .card-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 9 / 16;
      overflow: hidden;
      background: #fff;
      flex: 1 1 auto;           /* shrink ticket to keep footer visible */
      min-height: 0;
    }

    /* Media is absolutely positioned and contained */
    .bg-media {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      z-index: 0;
    }

    .text-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    .text {
      position: absolute;
      color: #111;
      overflow: hidden;
      text-shadow: none;
      word-wrap: break-word;
    }

    body.debug .text { outline: 1px dashed rgba(255,0,0,0.8); background: rgba(255,0,0,0.08); }

    canvas {
      position: absolute;
      z-index: 2;
      touch-action: none;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      flex-shrink: 0;           /* keep buttons visible */
    }

    .actions button {
      width: 100%;
      padding: 12px;
      font-size: 15px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.10);
      background: #fff;
      cursor: pointer;
    }

    .actions button.primary {
      background: linear-gradient(135deg, #f3d6b6, #f0caa0);
      border: none;
      color: #4a3b2a;
      font-weight: 600;
    }

    .link-status {
      width: 100%;
      font-size: 13px;
      color: #6b5a46;
      text-align: center;
      display: none;
    }

    .link-box { display: none; } /* hide raw URL entirely */

    .instructions {
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: #6b5a46;
      line-height: 1.4;
    }

    @media (max-width: 480px) {
      body { padding: 8px; }
      .container { gap: 8px; }
      .instructions { font-size: 13px; }
      .actions button { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="fatalError"><strong>Oops — something didn’t load correctly.</strong><br>Please refresh. If it keeps happening, open the console and copy the first red error line.</div>

    <!-- EDITOR -->
    <div class="editor" id="editor">
      <h2>Customize Your Ticket</h2>
      <p>Fill in the details below. You’ll preview your ticket before generating a shareable link.</p>

      <label class="field-label" for="nameInput">Recipient Name</label>
      <input id="nameInput" placeholder="Type here…" maxlength="40" />

      <label class="field-label" for="messageInput">Message</label>
      <input id="messageInput" placeholder="Type your custom message here…" />
      <div id="messageCounter">0/140</div>

      <label class="field-label" for="artistInput">Artist</label>
      <input id="artistInput" placeholder="Type here…" maxlength="40" />
      <label class="field-label" for="venueInput">Venue</label>
      <input id="venueInput" placeholder="Type here…" maxlength="50" />
      <label class="field-label" for="dateInput">Date</label>
      <input id="dateInput" placeholder="Type here…" maxlength="30" />

      <button id="previewBtn" type="button">Preview Ticket</button>
    </div>

    <!-- VIEW: Ticket + actions + instructions -->
    <div class="view" id="view">
      <div class="card-wrapper" id="card">
        <video id="bgVideo" class="bg-media" autoplay loop muted playsinline preload="auto"></video>
        <img id="bgImg" class="bg-media" alt="Scratch ticket" />

        <div class="text-layer">
          <div class="text" id="tName"></div>
          <div class="text" id="tEvent"></div>
          <div class="text" id="tArtist"></div>
          <div class="text" id="tVenue"></div>
          <div class="text" id="tDate"></div>
        </div>

        <canvas id="scratchCanvas" style="display:none;"></canvas>
      </div>

      <div class="actions" id="actions">
        <button id="backBtn" type="button">← Back to Edit</button>
        <button id="generateBtn" type="button">Generate Shareable Link</button>
        <button id="copyBtn" type="button" class="primary" style="display:none;">Copy Link</button>
        <div class="link-status" id="linkStatus">Link ready — tap <b>Copy Link</b> to share.</div>
        <div class="link-box" id="linkBox"></div>
      </div>

      <div class="instructions" id="instructions"></div>
    </div>
  </div>

  <script>
    const fatalError = document.getElementById('fatalError');
    window.addEventListener('error', (e) => {
      console.error(e.error || e.message);
      if (fatalError) fatalError.style.display = 'block';
    });

    function setMeta(id, value) {
      const el = document.getElementById(id);
      if (el && value) el.setAttribute('content', value);
    }

    function applySocialMetaFromConfig() {
      if (CONFIG.social?.title) document.title = CONFIG.social.title;
      setMeta('ogTitle', CONFIG.social?.title);
      setMeta('ogDesc', CONFIG.social?.description);
      setMeta('ogImage', CONFIG.social?.image);
      setMeta('ogType', CONFIG.social?.ogType);
      setMeta('twCard', CONFIG.social?.twitterCard);
      setMeta('twTitle', CONFIG.social?.title);
      setMeta('twDesc', CONFIG.social?.description);
      setMeta('twImage', CONFIG.social?.image);
    }

    function ensureGoogleFontsLink() {
      const link = document.getElementById('googleFontsLink');
      if (link && CONFIG.googleFontsHref) link.setAttribute('href', CONFIG.googleFontsHref);
    }

    function withCacheBust(url) {
      if (!url) return url;
      const v = String(CONFIG.assetsVersion || '').trim();
      if (!v) return url;
      return url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(v);
    }

    function encodeState(obj) {
      try {
        const compact = { n: obj.name || '', m: obj.message || '', a: obj.artist || '', v: obj.venue || '', d: obj.date || '' };
        Object.keys(compact).forEach(k => { if (!compact[k]) delete compact[k]; });
        const json = JSON.stringify(compact);
        const b64 = btoa(unescape(encodeURIComponent(json)));
        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      } catch { return ''; }
    }

    function decodeState(str) {
      try {
        let b64 = (str || '').replace(/-/g, '+').replace(/_/g, '/');
        while (b64.length % 4) b64 += '=';
        const json = decodeURIComponent(escape(atob(b64)));
        const compact = JSON.parse(json);
        if (!compact || typeof compact !== 'object') return null;
        return { name: compact.n || '', message: compact.m || '', artist: compact.a || '', venue: compact.v || '', date: compact.d || '' };
      } catch { return null; }
    }

    const params = new URLSearchParams(window.location.search);
    const isReveal = params.get('mode') === 'reveal';

    const editor = document.getElementById('editor');
    const view = document.getElementById('view');
    const card = document.getElementById('card');
    const actions = document.getElementById('actions');
    const instructions = document.getElementById('instructions');

    const bgVideo = document.getElementById('bgVideo');
    const bgImg = document.getElementById('bgImg');
    const scratchCanvas = document.getElementById('scratchCanvas');

    const inputs = {
      name: document.getElementById('nameInput'),
      message: document.getElementById('messageInput'),
      artist: document.getElementById('artistInput'),
      venue: document.getElementById('venueInput'),
      date: document.getElementById('dateInput')
    };

    const fields = {
      name: document.getElementById('tName'),
      message: document.getElementById('tEvent'),
      artist: document.getElementById('tArtist'),
      venue: document.getElementById('tVenue'),
      date: document.getElementById('tDate')
    };

    const state = { name: '', message: '', artist: '', venue: '', date: '' };
    let lastScale = 1;

    function setDebugMode(on) { document.body.classList.toggle('debug', !!on); }

    function updateMessageCounter() {
      const counter = document.getElementById('messageCounter');
      const max = Number(inputs.message?.maxLength || CONFIG.ui.messageMaxChars || 140);
      const len = (inputs.message?.value || '').length;
      if (counter) counter.textContent = `${len}/${max}`;
    }

    function pullInputsToState() {
      for (const key in inputs) state[key] = (inputs[key].value || '').trim();
    }

    function pushStateToInputs() {
      for (const key in inputs) inputs[key].value = state[key] || '';
      updateMessageCounter();
    }

    function loadStateFromParams() {
      const packed = params.get('d');
      if (packed) {
        const decoded = decodeState(packed);
        if (decoded) { Object.assign(state, decoded); return; }
      }
      for (const key in state) state[key] = (params.get(key) || '').trim();
    }

    function applyFieldLayout() {
      const wrapRect = card.getBoundingClientRect();
      const wrapW = wrapRect.width;
      const wrapH = wrapRect.height;

      const natW = (bgVideo && bgVideo.videoWidth) || (bgImg && bgImg.naturalWidth) || CONFIG.canvas.width;
      const natH = (bgVideo && bgVideo.videoHeight) || (bgImg && bgImg.naturalHeight) || CONFIG.canvas.height;

      const scale = Math.min(wrapW / natW, wrapH / natH);
      lastScale = scale;

      const contentW = natW * scale;
      const contentH = natH * scale;
      const offsetX = (wrapW - contentW) / 2;
      const offsetY = (wrapH - contentH) / 2;

      scratchCanvas.style.left = offsetX + 'px';
      scratchCanvas.style.top = offsetY + 'px';
      scratchCanvas.style.width = contentW + 'px';
      scratchCanvas.style.height = contentH + 'px';

      for (const key in CONFIG.fields) {
        const cfg = CONFIG.fields[key];
        const el = fields[key];
        if (!el) continue;

        el.style.left = (offsetX + cfg.x * scale) + 'px';
        el.style.top  = (offsetY + cfg.y * scale) + 'px';
        el.style.transform = 'translate(-50%, -50%)';
        el.style.width = (cfg.boxWidth * scale) + 'px';
        el.style.height = (cfg.boxHeight * scale) + 'px';

        const fontKey = cfg.fontKey || CONFIG.defaultFontKey;
        el.style.fontFamily = CONFIG.fonts[fontKey] || 'Arial, sans-serif';
        el.style.fontSize = (cfg.fontSize * scale) + 'px';
        el.style.fontWeight = String(cfg.fontWeight ?? 400);
        el.style.textAlign = cfg.align || 'center';

        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = (el.style.textAlign === 'left') ? 'flex-start' : (el.style.textAlign === 'right') ? 'flex-end' : 'center';

        if (key === 'message') {
          el.style.lineHeight = String(CONFIG.ui.messageLineHeight || 1.15);
          el.style.display = '-webkit-box';
          el.style.webkitBoxOrient = 'vertical';
          el.style.webkitLineClamp = String(CONFIG.ui.messageMaxLines || 2);
          el.style.overflow = 'hidden';
        } else {
          el.style.lineHeight = 'normal';
          el.style.webkitLineClamp = '';
          el.style.webkitBoxOrient = '';
          el.style.overflow = 'hidden';
        }
      }
    }

    function resetTextStyles() {
      for (const key in CONFIG.fields) {
        const el = fields[key];
        const cfg = CONFIG.fields[key];
        if (!el) continue;
        el.style.fontSize = (cfg.fontSize * lastScale) + 'px';
      }
    }

    function autoShrink(el, minAe) {
      const maxHeight = el.offsetHeight;
      let size = parseFloat(getComputedStyle(el).fontSize);
      const min = Math.max(8, Number(minAe || 10) * lastScale);
      let guard = 250;
      while ((el.scrollHeight > maxHeight || el.scrollWidth > el.offsetWidth) && size > min && guard-- > 0) {
        size -= 1;
        el.style.fontSize = size + 'px';
      }
    }

    function applyStateToFields() {
      resetTextStyles();
      for (const key in fields) fields[key].textContent = state[key] || '';
      for (const key in fields) autoShrink(fields[key], CONFIG.minFontSize[key]);
    }

    function showEditor() {
      editor.classList.add('active');
      view.classList.remove('active');
      scratchCanvas.style.display = 'none';
    }

    function showPreview() {
      editor.classList.remove('active');
      view.classList.add('active');
      scratchCanvas.style.display = 'none';
      actions.style.display = 'flex';
      instructions.textContent = 'Preview your ticket ✨ If anything looks off, tap Back to Edit to fix it.';
      requestAnimationFrame(() => { applyFieldLayout(); applyStateToFields(); });
    }

    function showReveal() {
      editor.classList.remove('active');
      view.classList.add('active');
      actions.style.display = 'none';
      instructions.textContent = '✨ Scratch to reveal your surprise! ✨';
      for (const key in fields) fields[key].style.visibility = 'hidden';
      scratchCanvas.style.display = 'block';
      requestAnimationFrame(() => { applyFieldLayout(); applyStateToFields(); });
    }

    function initScratch() {
      const canvas = scratchCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const overlay = new Image();
      overlay.crossOrigin = 'anonymous';
      overlay.src = withCacheBust(CONFIG.images.scratchOverlay);

      overlay.onload = () => {
        canvas.width = overlay.width;
        canvas.height = overlay.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(overlay, 0, 0);

        setTimeout(() => {
          for (const key in fields) fields[key].style.visibility = 'visible';
        }, Number(CONFIG.reveal?.textDelayMs || 150));
      };

      let scratching = false;
      let last = null;

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function eraseStroke(pos) {
        const size = Number(CONFIG.scratch?.brushSize || 120);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (!last) {
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y);
          ctx.lineTo(pos.x + 0.01, pos.y + 0.01);
          ctx.stroke();
          last = pos;
          return;
        }
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        last = pos;
      }

      function eraseCircle(pos) {
        const radius = Number(CONFIG.scratch?.brushSize || 120) / 2;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      function eraseAt(e) {
        const pos = getPos(e);
        const mode = String(CONFIG.scratch?.brushMode || 'stroke').toLowerCase();
        if (mode === 'circle') eraseCircle(pos);
        else eraseStroke(pos);
      }

      canvas.onpointerdown = (e) => { scratching = true; last = null; eraseAt(e); };
      canvas.onpointerup = () => { scratching = false; last = null; };
      canvas.onpointerleave = () => { scratching = false; last = null; };
      canvas.onpointermove = (e) => { if (!scratching) return; eraseAt(e); };
    }

    function runSelfTests() {
      console.assert(typeof CONFIG === 'object', 'CONFIG should exist');
      console.assert(editor && view && card, 'Core DOM nodes missing');
      for (const k in CONFIG.fields) console.assert(fields[k], `Missing field element: ${k}`);
    }

    (function boot() {
      applySocialMetaFromConfig();
      ensureGoogleFontsLink();
      setDebugMode(!isReveal && CONFIG.debug);

      if (inputs.message) {
        inputs.message.maxLength = Number(CONFIG.ui.messageMaxChars || 140);
        inputs.message.addEventListener('input', updateMessageCounter);
        updateMessageCounter();
      }

      // Load background media
      bgVideo.src = withCacheBust(CONFIG.images.backgroundVideo);
      bgVideo.addEventListener('error', () => {
        // fallback to image if video fails
        bgVideo.style.display = 'none';
        bgImg.style.display = 'block';
      });
      bgVideo.addEventListener('loadedmetadata', () => {
        applyFieldLayout();
        if (view.classList.contains('active')) applyStateToFields();
      });

      bgImg.src = withCacheBust(CONFIG.images.backgroundFallback);
      bgImg.style.display = 'none';
      bgImg.addEventListener('load', () => {
        applyFieldLayout();
        if (view.classList.contains('active')) applyStateToFields();
      });

      window.addEventListener('resize', () => {
        applyFieldLayout();
        if (view.classList.contains('active')) applyStateToFields();
      });

      if (isReveal) {
        loadStateFromParams();
        showReveal();
        applyStateToFields();
        initScratch();
      } else {
        showEditor();
      }

      const previewBtn = document.getElementById('previewBtn');
      previewBtn?.addEventListener('click', () => { pullInputsToState(); showPreview(); });

      const backBtn = document.getElementById('backBtn');
      backBtn?.addEventListener('click', () => { pushStateToInputs(); showEditor(); });

      const generateBtn = document.getElementById('generateBtn');
      const copyBtn = document.getElementById('copyBtn');
      const linkStatus = document.getElementById('linkStatus');
      let lastGeneratedLink = '';

      generateBtn?.addEventListener('click', () => {
        const base = (CONFIG.share && typeof CONFIG.share.baseUrl === 'string' && CONFIG.share.baseUrl.trim())
          ? CONFIG.share.baseUrl.trim()
          : window.location.href;

        const url = new URL(base);
        url.searchParams.set('mode', 'reveal');
        const packed = encodeState(state);
        if (packed) url.searchParams.set('d', packed);
        lastGeneratedLink = url.toString();

        if (linkStatus) linkStatus.style.display = 'block';
        if (copyBtn) copyBtn.style.display = 'block';

        // Avoid layout shift from UI updates
        requestAnimationFrame(() => { applyFieldLayout(); applyStateToFields(); });
      });

      copyBtn?.addEventListener('click', async () => {
        if (!lastGeneratedLink) return;
        const setCopied = () => {
          copyBtn.textContent = 'Copied! ✓';
          setTimeout(() => { copyBtn.textContent = 'Copy Link'; }, 1500);
        };
        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(lastGeneratedLink);
            setCopied();
            return;
          }
        } catch {}

        const temp = document.createElement('textarea');
        temp.value = lastGeneratedLink;
        temp.setAttribute('readonly', '');
        temp.style.position = 'fixed';
        temp.style.left = '-9999px';
        document.body.appendChild(temp);
        temp.select();
        try { document.execCommand('copy'); } catch {}
        document.body.removeChild(temp);
        setCopied();
      });

      runSelfTests();
    })();
  </script>
</body>
</html>
