<!DOCTYPE html>
<!--
  =============================================================
  Virtual Concert Scratch-Off Ticket (One-link, passive)
  =============================================================
  You mainly edit:
    1) Social meta tags (STATIC)
    2) CONFIG (all parameters in one spot)

  Notes:
    - Background supports MP4 (recommended) + optional fallback image.
    - Scratch overlay is a PNG.
    - Generated reveal links are spoiler-safe + shorter (single packed param).
    - Controlled reveal delay prevents text flashing before overlay is drawn.
  =============================================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Virtual Scratch Ticket</title>

  <!-- Social Preview (STATIC snapshot for platforms) -->
  <meta property="og:title" content="Virtual Scratch Ticket" id="ogTitle" />
  <meta property="og:description" content="Scratch to reveal your surprise!" id="ogDesc" />
  <meta property="og:image" content="https://i.imgur.com/GjmafAj.png" id="ogImage" />
  <meta property="og:type" content="website" id="ogType" />

  <meta name="twitter:card" content="summary_large_image" id="twCard" />
  <meta name="twitter:title" content="Virtual Scratch Ticket" id="twTitle" />
  <meta name="twitter:description" content="Scratch to reveal your surprise!" id="twDesc" />
  <meta name="twitter:image" content="https://i.imgur.com/GjmafAj.png" id="twImage" />

  <!-- Tiny built-in favicon to avoid 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8E%9F%EF%B8%8F%3C/text%3E%3C/svg%3E">

  <!-- UI font (soft/friendly) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link id="googleFontsLink" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Ropa+Sans:wght@400&family=Inter:wght@400;500;600&display=swap">

  <!-- ================= CONFIG (edit here) ================= -->
  <script>
    const CONFIG = {
      debug: false,

      // After Effects comp size
      canvas: { width: 1080, height: 1920 },

      images: {
        // Put background.mp4 in the SAME GitHub folder as index.html
        backgroundVideo: './background.mp4',
        // Optional fallback image/gif if video can’t load
        backgroundFallback: 'https://i.imgur.com/8GqRmQz.gif',
        // Scratch overlay PNG
        scratchOverlay: 'https://i.imgur.com/MKi32hJ.png'
      },

      // If you change fonts, update both googleFontsHref + fonts mappings.
      googleFontsHref: 'https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Ropa+Sans:wght@400&family=Inter:wght@400;500;600&display=swap',

      // Ticket text fonts
      fonts: {
        slab: "'Alfa Slab One', 'Georgia', serif",
        sans: "'Ropa Sans', 'Arial', sans-serif"
      },
      defaultFontKey: 'slab',

      // UI behaviors
      ui: {
        messageMaxChars: 140,
        messageMaxLines: 2,
        messageLineHeight: 1.15
      },

      // Fields defined in AE PIXELS.
      // x/y = CENTER of safe box. boxWidth/boxHeight = safe area.
      fields: {
        message: { x: 540, y: 630,  boxWidth: 901.7109, boxHeight: 145.7813, fontSize: 48, fontWeight: 400, align: 'center', fontKey: 'sans' },
        name:    { x: 540, y: 487,  boxWidth: 901.7109, boxHeight: 137.7813, fontSize: 80, fontWeight: 400, align: 'center', fontKey: 'slab' },
        artist:  { x: 540, y: 1052, boxWidth: 901.7109, boxHeight: 269.7813, fontSize: 80, fontWeight: 400, align: 'center', fontKey: 'slab' },
        venue:   { x: 306, y: 1523, boxWidth: 432.293,  boxHeight: 101.7871, fontSize: 30, fontWeight: 400, align: 'center', fontKey: 'slab' },
        date:    { x: 780, y: 1523, boxWidth: 432.293,  boxHeight: 101.7871, fontSize: 30, fontWeight: 400, align: 'center', fontKey: 'slab' }
      },

      // Min font sizes in AE px (auto-shrink won’t go below)
      minFontSize: { message: 14, name: 14, artist: 14, venue: 14, date: 14 },

      // Scratch brush
      scratch: {
        brushSize: 120,          // in overlay pixels
        brushMode: 'stroke'      // 'stroke' (smooth) or 'circle'
      },

      // Controlled reveal timing (ms) to prevent flash before overlay draws
      reveal: {
        textDelayMs: 150
      },

      // Generated link base URL (set after GitHub Pages is live)
      // Example: 'https://YOURUSERNAME.github.io/YOUR_REPO_NAME/'
      share: {
        baseUrl: ''
      },

      // Bump this when you change any asset URL to defeat caching
      assetsVersion: 'v3'
    };
  </script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', Arial, sans-serif;
      background: #fff;
      height: 100dvh;           /* mobile-safe viewport height */
      min-height: 100dvh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
      overflow: hidden;         /* no scrolling; shrink card instead */
    }

    .container {
      max-width: 600px;
      width: 100%;
      height: 100dvh;          /* ensures flex sizing keeps instructions visible */
      max-height: 100dvh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 10px;
      min-height: 0;
    }

    /* Friendly error banner (never blank) */
    #fatalError {
      display: none;
      padding: 12px;
      border-radius: 12px;
      background: #fff0f0;
      border: 1px solid rgba(176,0,32,0.25);
      color: #7a1d2a;
      font-family: 'Inter', Arial, sans-serif;
    }

    /* ---------- EDITOR ---------- */
    /* Default visible so if JS fails, page still shows */
    .editor { display: block; }

    .editor h2 {
      text-align: center;
      margin-bottom: 10px;
      font-weight: 600;
      color: #333;
    }

    .editor p {
      font-size: 14px;
      text-align: center;
      margin-bottom: 12px;
      color: #666;
      line-height: 1.4;
    }

    .editor input {
      width: 100%;
      padding: 14px;
      margin-bottom: 10px;
      font-size: 16px; /* prevent mobile auto-zoom */
      border-radius: 10px;
      border: 1px solid #ddd;
    }

    .editor input:focus {
      outline: none;
      border-color: #e8c9a8;
      box-shadow: 0 0 0 3px rgba(232,201,168,0.25);
    }

    .editor button {
      width: 100%;
      padding: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #f3d6b6, #f0caa0);
      color: #4a3b2a;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    }

    #messageCounter {
      font-size: 12px;
      color: #777;
      margin: -4px 0 10px;
      text-align: right;
    }

    /* ---------- CARD ---------- */
    .card-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 9 / 16;
      display: none;
      overflow: hidden;
      flex: 1 1 auto;          /* flex shrinks card so instructions stay on-screen */
      min-height: 0;
    }

    .card-wrapper.active { display: block; }

    .background-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    .text-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    .text {
      position: absolute;
      color: #111;
      overflow: hidden;
      text-shadow: none;
      word-wrap: break-word;
    }

    /* Debug overlay */
    body.debug .text { outline: 1px dashed rgba(255,0,0,0.8); background: rgba(255,0,0,0.08); }

    canvas {
      position: absolute;
      touch-action: none;
      z-index: 2;
    }

    .actions {
      display: none;
      flex-shrink: 0;
      gap: 8px;
    }

    .actions button {
      width: 100%;
      padding: 12px;
      font-size: 15px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.10);
      background: #fff;
      cursor: pointer;
    }

    .actions button.primary {
      background: linear-gradient(135deg, #f3d6b6, #f0caa0);
      border: none;
      color: #4a3b2a;
      font-weight: 600;
    }

    .link-box {
      word-break: break-all;
      font-size: 13px;
      background: #fbf6ef;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.08);
      color: #4a3b2a;
      height: 88px;
      overflow: auto;
    }

    .instructions {
      text-align: center;
      font-size: 14px;
      color: #6b5a46;
      line-height: 1.4;
      flex-shrink: 0;
      padding-bottom: 6px;
    }

    @media (max-width: 480px) {
      body { padding: 8px; }
      .container { gap: 8px; }
      .editor input { padding: 14px; font-size: 16px; }
      .editor button { padding: 12px; font-size: 15px; }
      .instructions { font-size: 13px; }
      .link-box { height: 76px; }
    }
      .instructions { font-size: 13px; }
      .link-box { height: 76px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="fatalError"><strong>Oops — something didn’t load correctly.</strong><br>Please refresh the page. If it keeps happening, open the console and copy the first red error line.</div>

    <!-- EDITOR -->
    <div class="editor" id="editor">
      <h2>Customize Your Ticket</h2>
      <p>Fill in the details below. You’ll preview your ticket before generating a shareable link.</p>

      <input id="nameInput" placeholder="Recipient Name" maxlength="40" />

      <input id="messageInput" placeholder="Message (Type your custom message here)" />
      <div id="messageCounter">0/140</div>

      <input id="artistInput" placeholder="Artist" maxlength="40" />
      <input id="venueInput" placeholder="Venue" maxlength="50" />
      <input id="dateInput" placeholder="Date" maxlength="30" />

      <button id="previewBtn" type="button">Preview Ticket</button>
    </div>

    <!-- CARD -->
    <div class="card-wrapper" id="card">
      <video id="bgVideo" class="background-image" autoplay loop muted playsinline preload="auto">
        <source id="bgVideoSource" src="./background.mp4" type="video/mp4">
        <img id="bgImg" src="https://i.imgur.com/8GqRmQz.gif" class="background-image" alt="Scratch ticket" />
      </video>

      <div class="text-layer">
        <div class="text" id="tName"></div>
        <div class="text" id="tEvent"></div>
        <div class="text" id="tArtist"></div>
        <div class="text" id="tVenue"></div>
        <div class="text" id="tDate"></div>
      </div>

      <canvas id="scratchCanvas" style="display:none;"></canvas>
    </div>

    <!-- ACTIONS -->
    <div class="actions" id="actions">
      <button id="backBtn" type="button">← Back to Edit</button>
      <button id="generateBtn" type="button">Generate Shareable Link</button>
      <button id="copyBtn" type="button" style="display:none;">Copy Link</button>
      <div class="link-box" id="linkBox"></div>
    </div>
    </div>

    <div class="instructions" id="instructions"></div>
  </div>

  <script>
    // Show a friendly message if any script error happens
    const fatalError = document.getElementById('fatalError');
    window.addEventListener('error', (e) => {
      console.error(e.error || e.message);
      if (fatalError) fatalError.style.display = 'block';
    });

    // Helpers
    function setMeta(id, value) {
      const el = document.getElementById(id);
      if (el && value) el.setAttribute('content', value);
    }

    function applySocialMetaFromConfig() {
      if (CONFIG.social?.title) document.title = CONFIG.social.title;
      setMeta('ogTitle', CONFIG.social?.title);
      setMeta('ogDesc', CONFIG.social?.description);
      setMeta('ogImage', CONFIG.social?.image);
      setMeta('ogType', CONFIG.social?.ogType);
      setMeta('twCard', CONFIG.social?.twitterCard);
      setMeta('twTitle', CONFIG.social?.title);
      setMeta('twDesc', CONFIG.social?.description);
      setMeta('twImage', CONFIG.social?.image);
    }

    function ensureGoogleFontsLink() {
      const link = document.getElementById('googleFontsLink');
      if (link && CONFIG.googleFontsHref) link.setAttribute('href', CONFIG.googleFontsHref);
    }

    function withCacheBust(url) {
      if (!url) return url;
      const v = String(CONFIG.assetsVersion || '').trim();
      if (!v) return url;
      return url + (url.includes('?') ? '&' : '?') + 'v=' + encodeURIComponent(v);
    }

    // Short + spoiler-safe link packing (base64url)
    function encodeState(obj) {
      try {
        const compact = {
          n: obj.name || '',
          m: obj.message || '',
          a: obj.artist || '',
          v: obj.venue || '',
          d: obj.date || ''
        };
        Object.keys(compact).forEach(k => { if (!compact[k]) delete compact[k]; });
        const json = JSON.stringify(compact);
        const b64 = btoa(unescape(encodeURIComponent(json)));
        return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      } catch {
        return '';
      }
    }

    function decodeState(str) {
      try {
        let b64 = (str || '').replace(/-/g, '+').replace(/_/g, '/');
        while (b64.length % 4) b64 += '=';
        const json = decodeURIComponent(escape(atob(b64)));
        const compact = JSON.parse(json);
        if (!compact || typeof compact !== 'object') return null;
        return {
          name: compact.n || '',
          message: compact.m || '',
          artist: compact.a || '',
          venue: compact.v || '',
          date: compact.d || ''
        };
      } catch {
        return null;
      }
    }

    // DOM
    const params = new URLSearchParams(window.location.search);
    const isReveal = params.get('mode') === 'reveal';

    const editor = document.getElementById('editor');
    const card = document.getElementById('card');
    const actions = document.getElementById('actions');
    const instructions = document.getElementById('instructions');

    const bgVideo = document.getElementById('bgVideo');
    const bgVideoSource = document.getElementById('bgVideoSource');
    const bgImg = document.getElementById('bgImg');
    const scratchCanvas = document.getElementById('scratchCanvas');

    const inputs = {
      name: document.getElementById('nameInput'),
      message: document.getElementById('messageInput'),
      artist: document.getElementById('artistInput'),
      venue: document.getElementById('venueInput'),
      date: document.getElementById('dateInput')
    };

    const fields = {
      name: document.getElementById('tName'),
      message: document.getElementById('tEvent'),
      artist: document.getElementById('tArtist'),
      venue: document.getElementById('tVenue'),
      date: document.getElementById('tDate')
    };

    const state = { name: '', message: '', artist: '', venue: '', date: '' };
    let lastScale = 1;

    function setDebugMode(on) {
      document.body.classList.toggle('debug', !!on);
    }

    function updateMessageCounter() {
      const counter = document.getElementById('messageCounter');
      const max = Number(inputs.message?.maxLength || CONFIG.ui.messageMaxChars || 140);
      const len = (inputs.message?.value || '').length;
      if (counter) counter.textContent = `${len}/${max}`;
    }

    function pullInputsToState() {
      for (const key in inputs) state[key] = (inputs[key].value || '').trim();
    }

    function pushStateToInputs() {
      for (const key in inputs) inputs[key].value = state[key] || '';
      updateMessageCounter();
    }

    function loadStateFromParams() {
      const packed = params.get('d');
      if (packed) {
        const decoded = decodeState(packed);
        if (decoded) {
          Object.assign(state, decoded);
          return;
        }
      }
      // Back-compat
      for (const key in state) state[key] = (params.get(key) || '').trim();
    }

    function applyFieldLayout() {
      const wrapRect = card.getBoundingClientRect();
      const wrapW = wrapRect.width;
      const wrapH = wrapRect.height;

      const natW = (bgVideo && bgVideo.videoWidth) || (bgImg && bgImg.naturalWidth) || CONFIG.canvas.width;
      const natH = (bgVideo && bgVideo.videoHeight) || (bgImg && bgImg.naturalHeight) || CONFIG.canvas.height;

      const scale = Math.min(wrapW / natW, wrapH / natH);
      lastScale = scale;

      const contentW = natW * scale;
      const contentH = natH * scale;
      const offsetX = (wrapW - contentW) / 2;
      const offsetY = (wrapH - contentH) / 2;

      // Canvas matches contained area
      scratchCanvas.style.left = offsetX + 'px';
      scratchCanvas.style.top = offsetY + 'px';
      scratchCanvas.style.width = contentW + 'px';
      scratchCanvas.style.height = contentH + 'px';

      for (const key in CONFIG.fields) {
        const cfg = CONFIG.fields[key];
        const el = fields[key];
        if (!el) continue;

        el.style.left = (offsetX + cfg.x * scale) + 'px';
        el.style.top  = (offsetY + cfg.y * scale) + 'px';
        el.style.transform = 'translate(-50%, -50%)';

        el.style.width = (cfg.boxWidth * scale) + 'px';
        el.style.height = (cfg.boxHeight * scale) + 'px';

        const fontKey = cfg.fontKey || CONFIG.defaultFontKey;
        el.style.fontFamily = CONFIG.fonts[fontKey] || 'Arial, sans-serif';
        el.style.fontSize = (cfg.fontSize * scale) + 'px';
        el.style.fontWeight = String(cfg.fontWeight ?? 400);
        el.style.textAlign = cfg.align || 'center';

        // center within box
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = (el.style.textAlign === 'left') ? 'flex-start' : (el.style.textAlign === 'right') ? 'flex-end' : 'center';

        if (key === 'message') {
          el.style.lineHeight = String(CONFIG.ui.messageLineHeight || 1.15);
          el.style.display = '-webkit-box';
          el.style.webkitBoxOrient = 'vertical';
          el.style.webkitLineClamp = String(CONFIG.ui.messageMaxLines || 2);
          el.style.overflow = 'hidden';
        } else {
          el.style.lineHeight = 'normal';
          el.style.webkitLineClamp = '';
          el.style.webkitBoxOrient = '';
          el.style.overflow = 'hidden';
        }
      }
    }

    function resetTextStyles() {
      for (const key in CONFIG.fields) {
        const el = fields[key];
        const cfg = CONFIG.fields[key];
        if (!el) continue;
        el.style.fontSize = (cfg.fontSize * lastScale) + 'px';
      }
    }

    function autoShrink(el, minAe) {
      const maxHeight = el.offsetHeight;
      let size = parseFloat(getComputedStyle(el).fontSize);
      const min = Math.max(8, Number(minAe || 10) * lastScale);
      let guard = 250;
      while ((el.scrollHeight > maxHeight || el.scrollWidth > el.offsetWidth) && size > min && guard-- > 0) {
        size -= 1;
        el.style.fontSize = size + 'px';
      }
    }

    function applyStateToFields() {
      resetTextStyles();
      for (const key in fields) fields[key].textContent = state[key] || '';
      for (const key in fields) autoShrink(fields[key], CONFIG.minFontSize[key]);
    }

    function showEditor() {
      editor.style.display = 'block';
      card.classList.remove('active');
      actions.style.display = 'none';
      instructions.textContent = '';
      scratchCanvas.style.display = 'none';
    }

    function showPreview() {
      editor.style.display = 'none';
      card.classList.add('active');
      actions.style.display = 'flex';
      actions.style.flexDirection = 'column';
      instructions.textContent = 'Preview your ticket ✨ If anything looks off, tap “Back to Edit” to fix it.';
      scratchCanvas.style.display = 'none';

      requestAnimationFrame(() => {
        applyFieldLayout();
        applyStateToFields();
      });
    }

    function showReveal() {
      editor.style.display = 'none';
      actions.style.display = 'none';
      card.classList.add('active');
      instructions.textContent = '✨ Scratch to reveal your surprise! ✨';

      // Hide all text until overlay is drawn
      for (const key in fields) fields[key].style.visibility = 'hidden';

      scratchCanvas.style.display = 'block';

      requestAnimationFrame(() => {
        applyFieldLayout();
        applyStateToFields();
      });
    }

    function initScratch() {
      const canvas = scratchCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const overlay = new Image();
      overlay.crossOrigin = 'anonymous';
      overlay.src = withCacheBust(CONFIG.images.scratchOverlay);

      overlay.onload = () => {
        canvas.width = overlay.width;
        canvas.height = overlay.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(overlay, 0, 0);

        // Reveal text after overlay is definitely drawn
        setTimeout(() => {
          for (const key in fields) fields[key].style.visibility = 'visible';
        }, Number(CONFIG.reveal?.textDelayMs || 150));
      };

      // reset listeners
      canvas.onpointerdown = null;
      canvas.onpointerup = null;
      canvas.onpointerleave = null;
      canvas.onpointermove = null;

      let scratching = false;
      let last = null;

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function eraseCircle(pos) {
        const radius = Number(CONFIG.scratch?.brushSize || 120) / 2;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      function eraseStroke(pos) {
        const size = Number(CONFIG.scratch?.brushSize || 120);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (!last) {
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y);
          ctx.lineTo(pos.x + 0.01, pos.y + 0.01);
          ctx.stroke();
          last = pos;
          return;
        }
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        last = pos;
      }

      function eraseAt(e) {
        const pos = getPos(e);
        const mode = String(CONFIG.scratch?.brushMode || 'stroke').toLowerCase();
        if (mode === 'circle') eraseCircle(pos);
        else eraseStroke(pos);
      }

      canvas.onpointerdown = (e) => { scratching = true; last = null; eraseAt(e); };
      canvas.onpointerup = () => { scratching = false; last = null; };
      canvas.onpointerleave = () => { scratching = false; last = null; };
      canvas.onpointermove = (e) => { if (!scratching) return; eraseAt(e); };
    }

    function runSelfTests() {
      console.assert(typeof CONFIG === 'object', 'CONFIG should exist');
      console.assert(CONFIG.images && CONFIG.images.scratchOverlay, 'scratchOverlay must exist');
      for (const key in CONFIG.fields) {
        console.assert(fields[key], `Missing field element for ${key}`);
      }
    }

    // Boot
    (function boot() {
      applySocialMetaFromConfig();
      ensureGoogleFontsLink();
      setDebugMode(!isReveal && CONFIG.debug);

      // Message max length
      if (inputs.message) {
        inputs.message.maxLength = Number(CONFIG.ui.messageMaxChars || 140);
        inputs.message.addEventListener('input', updateMessageCounter);
        updateMessageCounter();
      }

      // Load media URLs (cache-busted)
      if (bgVideoSource) bgVideoSource.src = withCacheBust(CONFIG.images.backgroundVideo);
      if (bgVideo) {
        bgVideo.load();
        bgVideo.onloadedmetadata = () => {
          applyFieldLayout();
          if (card.classList.contains('active')) applyStateToFields();
        };
      }
      if (bgImg) {
        bgImg.src = withCacheBust(CONFIG.images.backgroundFallback);
        bgImg.onload = () => {
          applyFieldLayout();
          if (card.classList.contains('active')) applyStateToFields();
        };
      }

      // Resize
      window.addEventListener('resize', () => {
        applyFieldLayout();
        if (card.classList.contains('active')) applyStateToFields();
      });

      // Routing
      if (isReveal) {
        loadStateFromParams();
        showReveal();
        applyStateToFields();
        initScratch();
      } else {
        showEditor();
      }

      // Buttons
      const previewBtn = document.getElementById('previewBtn');
      if (previewBtn) {
        previewBtn.addEventListener('click', () => {
          pullInputsToState();
          showPreview();
        });
      }

      const backBtn = document.getElementById('backBtn');
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          pushStateToInputs();
          showEditor();
        });
      }

      const generateBtn = document.getElementById('generateBtn');
      const copyBtn = document.getElementById('copyBtn');
      if (generateBtn) {
        generateBtn.addEventListener('click', () => {
          const base = (CONFIG.share && typeof CONFIG.share.baseUrl === 'string' && CONFIG.share.baseUrl.trim())
            ? CONFIG.share.baseUrl.trim()
            : window.location.href;

          const url = new URL(base);
          url.searchParams.set('mode', 'reveal');
          const packed = encodeState(state);
          if (packed) url.searchParams.set('d', packed);

          const link = url.toString();
          const linkBox = document.getElementById('linkBox');
          if (linkBox) linkBox.textContent = link;

          if (copyBtn) {
            copyBtn.style.display = 'block';
            copyBtn.textContent = 'Copy Link';
            copyBtn.classList.add('primary');
          }

          // Re-apply layout after link renders
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              applyFieldLayout();
              applyStateToFields();
            });
          });
        });
      }

      if (copyBtn) {
        copyBtn.addEventListener('click', async () => {
          const linkBox = document.getElementById('linkBox');
          const text = linkBox?.textContent || '';
          if (!text) return;

          try {
            await navigator.clipboard.writeText(text);
            copyBtn.textContent = 'Copied! ✓';
            setTimeout(() => { copyBtn.textContent = 'Copy Link'; }, 1500);
          } catch {
            // Fallback for older browsers
            const temp = document.createElement('textarea');
            temp.value = text;
            document.body.appendChild(temp);
            temp.select();
            document.execCommand('copy');
            document.body.removeChild(temp);
            copyBtn.textContent = 'Copied! ✓';
            setTimeout(() => { copyBtn.textContent = 'Copy Link'; }, 1500);
          }
        });
      }
          });
        });
      }

      runSelfTests();
    })();
  </script>
</body>
</html>
